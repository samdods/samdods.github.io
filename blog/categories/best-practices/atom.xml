<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: best-practices | ]]></title>
  <link href="http://sam.dods.co/blog/categories/best-practices/atom.xml" rel="self"/>
  <link href="http://sam.dods.co/"/>
  <updated>2016-12-01T22:11:58+00:00</updated>
  <id>http://sam.dods.co/</id>
  <author>
    <name><![CDATA[Sam Dods]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Delegate Pattern in Swift]]></title>
    <link href="http://sam.dods.co/blog/2016/12/01/delegate-pattern-swift/"/>
    <updated>2016-12-01T21:39:37+00:00</updated>
    <id>http://sam.dods.co/blog/2016/12/01/delegate-pattern-swift</id>
    <content type="html"><![CDATA[<h1>Delegate Pattern in Swift</h1>

<p>I started a long and mostly one-sided debate in the office last week, by suggesting that we should <em>not</em> change our delegate method signatures to conform to the Swift principle of <strong>omitting needless words</strong>.</p>

<p>My side of the debate was that we should follow the convention of prefixing delegate methods with the name of the delegating class, as follows:</p>

<pre><code class="swift">func scrollViewDidScroll(_ scrollView: UIScrollView)
</code></pre>

<p>The other side of the debate was, “Come on, man, this is Swift 3. Those words are not needed, so omit them! It’s more clear at the point of use!” And this side of the debate suggested we adopt the following naming convention:</p>

<pre><code class="swift">func didScroll(in scrollView: UIScrollView)
</code></pre>

<p>In this article, I’ll rationalise my side of the debate, but also ask the question: is delegation even the right pattern?</p>

<!-- More -->


<h2>Clarity at the point of use</h2>

<p>A large part of writing an API is to allow others to invoke our method implementations. We provide an interface to our code. And we should make is as simple as possible to interface with. We’ll write a method once, but many people will call our method, possibly many times. So clarity at the point of use is more important than at the point of declaration. This is also referred to as clarity at the call site.</p>

<p>Delegate methods are different to typical methods in our interface. By declaring a delegate protocol, we are writing a contract. This contract defines an interface to code that we expect others to implement. The roles are reversed for delegate methods. Instead of inviting someone to invoke a method that we implemented, we’re asking them to implement the method, so that we can call it. So the guidelines should be reversed too. We will call the method once, but many people will implement that method, possibly many times. The “point of use” now refers to where the method is implemented by those using our API. I’ll refer to this as the implementation site.</p>

<p>The most important thing is still clarity at the point of use, only that point of use is now the implementation site. And the most important thing to ensure clarity around is that the method &ldquo;belongs to&rdquo; our API. That is to say, &ldquo;you implement it, but don&rsquo;t call it. We&rsquo;ll call it.&rdquo; The best way to make this clear is to prefix the method with the name of the delegating class.</p>

<p><em>As as aside, even if the guidelines were not reversed, I still don&rsquo;t agree that <code>didScroll(in:)</code> is clearer at the call site. <code>delegate?.didScroll(in: self)</code> is misleading. It wasn&rsquo;t the delegate that scrolled in self – it was self that scrolled!</em></p>

<h2>Passing a reference to the sender</h2>

<p>While this debate was taking place, it was also touted that you needn&rsquo;t pass the reference to the sender. &ldquo;If you don&rsquo;t need it, don&rsquo;t send it!&rdquo;</p>

<p>Actually, the delegate pattern is defined such that the delegate can implement the method on behalf of the delegating class, with the full original context of the sender. This is achieved in Swift by sending a reference to <code>self</code>. And when defining an API for others to consume, one should stick to the definition of the delegate pattern by providing the original context.</p>

<p>Moreover, you risk taking brevity too far and instead of having:</p>

<pre><code class="swift">func didScroll(in scrollView: UIScrollView)
</code></pre>

<p>you&rsquo;ll end up with just:</p>

<pre><code class="swift">func didScroll()
</code></pre>

<p>And where&rsquo;s the sense in that?!</p>

<p>A lot of people are suggesting that Apple just haven&rsquo;t updated their <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html#//apple_ref/doc/uid/20001282-1001803-BCIDAIJE">Coding Guidelines for Delegate Methods</a> since Objective-C. And if they did, perhaps they would review it with Swift&rsquo;s <a href="https://swift.org/documentation/api-design-guidelines/">API Design Guidelines</a> in mind.</p>

<p>However, I disagree again. Apple provided documentation on <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID276">Delegation</a> in the book <em>The Swift Programming Language (updated for Swift 3.0.1)</em>. It doesn&rsquo;t explicitly state that a reference to the sender must be passed as an argument, but they do follow that convention in all of their examples. They also (almost) follow the convention of prefixing all the delegate methods with the name of the delegating class. (Although in their examples, it&rsquo;s actually a delegating protocol type <code>DiceGame</code> and the delegate methods each have the consistent prefix <code>game</code>.)</p>

<h2>Following convention</h2>

<p>Conventions are there to be followed. But rules are there to be broken, right? Otherwise how would we innovate? I agree with this, but I don&rsquo;t agree with breaking convention to end up with something that&rsquo;s <em>less</em> clear.</p>

<p>In <a href="https://twitter.com/khanlou">Soroush Khanlou</a>&rsquo;s article about <a href="http://khanlou.com/2016/09/swifty-delegates/">Swifty Delegates</a>, he suggests that in an ideal future Apple would update UIKit to follow a more &lsquo;Swifty&rsquo; delegate method signature. UIKit already strays from convention with the <code>UITableViewDataSource</code> method <code>numberOfSections(in:)</code>.</p>

<p>While I respect Soroush&rsquo;s opinion, and have thoroughly enjoyed many of his articles, I disagree that this is the future. I actually think UIKit would be better if anomolies like this were corrected. So this example would become <code>tableViewNumberOfSections(_:)</code>.</p>

<p>The prefix is there to distinguish between other methods that the delegate might want to implement. Apple is delegating this functionality to the consumer of its API. They are asking the consumer to implement this method. I don&rsquo;t want to implement it, but I have to, because Apple expects me to. And as such, I&rsquo;d prefer it to have the <code>tableView</code> prefix, so I know – and others after me know – that this method belongs to the delegating class, and it&rsquo;s not just some method I&rsquo;ve implemented for my own benefit.</p>

<p>But of course, that&rsquo;s just my opinion. I&rsquo;ve expressed my will and desire.</p>

<p>But what is ultimately much more important, is this:</p>

<p>If you want to later query the number of sections in the table, from your delegate (say, a view controller), are you going to call:</p>

<pre><code class="swift">self.numberOfSections(in: tableView) // Swifty-style delegate method implemented on the view controller
</code></pre>

<p>or the following?</p>

<pre><code class="swift">self.tableView.numberOfSections
</code></pre>

<p>I&rsquo;d recommend the latter, although with the number of sections it&rsquo;s <em>probably</em> safe to call either. But what if you want to find the cell for a given row? Assuming UIKit had taken Soroush&rsquo;s advice, then which of the following would you call?</p>

<pre><code class="swift">self.cellForRow(at: indexPath, in: tableView) // Swifty-style delegate method implemented on the view controller
</code></pre>

<p>or</p>

<pre><code class="swift">self.tableView.cellForRow(at: indexPath)
</code></pre>

<p>It might be tempting to call the former because you start typing <code>cell...</code> and auto-complete serves it to you on a plate. But my advice would be to call the latter, given that only the <em>delegating class</em> should ever call the <em>delegate method</em>.</p>

<p>But wouldn&rsquo;t it be really confusing if those <code>UITableViewDataSource</code> methods were really declared as Soroush suggested? And if we all stray from convention – to make our delegate method signatures more &lsquo;Swifty&#8217; – then we risk making our APIs confusing. The prefix convention highlights that this method should only be called by the delegating class.</p>

<h2>But is delegation even the correct pattern?</h2>

<p>If you strictly follow the <a href="https://www.objc.io/issues/7-foundation/communication-patterns/">guidelines laid out by the objc.io guys</a>, then you might find yourself using delegation a lot less. But their article isn&rsquo;t new, so is the delegate pattern still overused? Probably, yes. But then if we&rsquo;re drawing inspiration from UIKit et al, then it&rsquo;s obvious why.</p>

<p>But blocks weren&rsquo;t present at the birth of UIKit. They came on the scene with iOS 4, and quickly gained popularity with many open source libraries extending UIKit to provide block-based APIs. Blocks, or now <em>closures</em>, may be much more appropriate in many of the places the delegate pattern is used.</p>

<p>The dictionary definition of the verb <em>to delegate</em> is to:</p>

<blockquote><p>entrust a task or responsibility to another entity, typically one who is less senior than oneself.</p></blockquote>

<p>Now, I&rsquo;m not going to get into a debate about who&rsquo;s more senior: a view controller or a table view. But the important bit is that delegation is <em>entrusting a task</em> to another entity. It&rsquo;s <em>not</em> about notifying!</p>

<p>Some examples that came up during our debate were similar to this:</p>

<pre><code class="swift">func myCellDidTapAdd(_ cell: MyCell)
</code></pre>

<p>or</p>

<pre><code>func didTapAdd(on cell: MyCell)
</code></pre>

<p>This is a prime example of when a closure would solve the problem better than the delegate pattern.</p>

<h3>Closures</h3>

<p>A closure may be better here because you&rsquo;ll typically have access to the cell&rsquo;s index path at the point at which you set the closure. The index path is much more useful than the cell itself, which would be passed to the delegate method implementation. This is because you&rsquo;re likely to look up an item from your data source using its index. It avoids having to call <code>tableView.indexPath(for: cell)</code> and guarding against a <code>nil</code> index path being returned. And within the closure you can call your own method, which <em>you&rsquo;ve</em> implemented because <em>you</em> want it to do something, with the arguments <em>you</em> need, rather than it being dictated by a delegating class that you <em>must</em> implement it.</p>

<h3>Target/Action</h3>

<p>And target/action might be better in many places too. Target/action is a great mechanism, which was vastly improved by the addition of <code>#selector</code> in Swift 2.2. If it&rsquo;s a simple case of delegating that something was tapped, why not make it a <code>UIControl</code> subclass and hook it up via target/action?</p>

<p>I&rsquo;ve seen so many times a custom view with a <code>UITapGestureRecognizer</code>, where the method for the tap delegates its handling to the custom view&rsquo;s delegate. Have you ever seen something like this?</p>

<pre><code class="swift">@IBAction private func handleTap(tap: UITapGestureRecognizer) {
    delegate?.myCustomViewWasTapped(self)
}
</code></pre>

<p>Why not try the following?</p>

<pre><code class="swift">@IBAction private func handleTap(tap: UITapGestureRecognizer) {
    sendActions(for: .touchUpInside)
}
</code></pre>

<p>Now you can either set up the target/action in code, or hook it up in interface builder if appropriate.</p>

<p>And, as mentioned above with closures, the method that&rsquo;s implemented by the consumer can be whatever they choose. Both with closures and target/action, we allow the consumer of our API to write whatever methods they please, and they will still be &ldquo;notified&rdquo; by our object.</p>

<p>This means as a consumer we can hook the API into a method like <code>dismissCustomView()</code> instead of having to implement the delegate method <code>customViewDidTapDismiss(_:)</code>. This also means we don&rsquo;t need a separate method if we want to call this from somewhere else in our own code.</p>

<p>Furthermore, with target/action, it&rsquo;s the receiver that decides whether or not they need a reference to the sender. And if they want it, they&rsquo;ve got it. And if they don&rsquo;t, they can implement a method that takes no arguments.</p>

<h2>Conclusion</h2>

<p>I do think delegate methods are overused, but if we continue to use them then I think we should stick to convention. Mainly to avoid confusion, but also out of respect for the consumers of ones API – even if those consumers are only ones colleagues, or even oneself!</p>

<p>So when is it right to use the delegate pattern?</p>

<p>Typically I find that if you want something returned, then the delegate pattern is probably a good shout. Say, if you want to check if you should do something, then you&rsquo;ll expect a <code>Bool</code> to be returned. And this makes sense with the definition of delegation too. You&rsquo;re entrusting someone else to provide some information that you need.</p>

<p>And I&rsquo;d suggest avoiding the delegate pattern if you&rsquo;re simply notifying another object of an action.</p>

<p>But of course, there are no hard and fast rules, and that&rsquo;s what&rsquo;s so great about programming – we can always find better ways of doing things, and <a href="https://8thlight.com/blog/daniel-irvine/2016/11/11/perfect-code-is-an-illusion.html?utm_campaign=iOS%2BDev%2BWeekly&amp;utm_medium=email&amp;utm_source=iOS_Dev_Weekly_Issue_277">we don&rsquo;t need to get it right first time</a>!</p>

<p>And if we continue to ask questions like this, then we continue to improve as developers. And surely that&rsquo;s the most important thing.</p>

<p>Thanks for reading!</p>

<p><em>This article ended up being a bit longer than I&rsquo;d planned, so seriously, thanks for reading! If you&rsquo;re interested in continuous improvement and beating things up to find better solutions, then you might be interested in joining a great team at <a href="http://www.theappbusiness.com">The App Business</a>.</em></p>

<p><em>If you enjoyed this article, please <a href="http://twitter.com/dodsios">follow me on twitter</a> or subscribe to my <a href="http://octopress.dev/atom.xml">RSS feed</a> for more of the same.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift best practices]]></title>
    <link href="http://sam.dods.co/blog/2015/09/21/some-swift-best-practices/"/>
    <updated>2015-09-21T08:00:37+01:00</updated>
    <id>http://sam.dods.co/blog/2015/09/21/some-swift-best-practices</id>
    <content type="html"><![CDATA[<p>I started learning Swift the day it was announced and read Apple&rsquo;s <em>The Swift Programming Language</em> in the first couple of days. I began writing small components and playing around with Swift at the same time, but never felt it was mature enough to begin a big project with it.</p>

<p>That was until Swift 2.0 was announced in June. Since then I&rsquo;ve been using it more and more and recently started writing a major project at <a href="www.theappbusiness.com">The App Business</a> purely in Swift 2.0.</p>

<p>Read on for some of my observations &ndash; some are obvious and common, but hopefully some will be new to most people. Let me know if you have any of your own that I could add to the list!</p>

<!-- More -->


<h2>Prefer <code>let</code> over <code>var</code></h2>

<p>Train your brain and your keyboard-bashing fingers to write <code>let</code> by default. There may be times when you know up-front you&rsquo;ll need a mutable variable, but I still recommend using <code>let</code> until you absolutely need to modify its value. This is the most obvious of my best practices, but it&rsquo;s super important, so still worth a mention.</p>

<h2>Prefer <code>private</code> access control</h2>

<p>Again, this one is obvious, but still worth pointing out. It&rsquo;s always better to keep as much of your implementation <code>private</code>, which means it can only be accessed from the same source file.</p>

<h2>Prefer non-optionals</h2>

<p>Optionals are great. This concept does exist in other languages (Scala, Haskell, etc.), but much respect has to go to Chris Lattner for bringing it to Swift.</p>

<p>However, as useful as they can be, I would still try to avoid them where possible. It leads to much cleaner code if you have variables and properties that you know hold a value, or functions that you can guarantee return a non-nil value.</p>

<p>For example, I would prefer a function to throw an exception if it is unable to return a non-nil value. Take the SDK&rsquo;s <code>NSJSONSerialization.JSONObjectWithData</code> function. It guarantees that if it returns anything, it will return a non-nil <code>AnyObject</code>, otherwise it throws an exception.</p>

<h2>Prefer <code>guard let</code> over <code>if let</code></h2>

<p>What can you do in an <code>if let</code> code block? I would <em>almost</em> always opt for a <code>guard let</code> and return early. Early return tends to make the code that follows easier to read because you can guarantee the state of variables at that point. If you can&rsquo;t calculate a required value, then return early.</p>

<h2>Don&rsquo;t be afraid to <code>throw</code></h2>

<p>Instead of returning early, consider throwing an error, which is an alternative exit point from the function. Exception handling in Objective-C (<code>@try @catch</code>) was always possible, but frowned upon. In Swift, throwing errors is a fundamental concept and should be embraced.</p>

<p>I had a parsing function that returned an optional, returning <code>nil</code> if the data couldn&rsquo;t be parsed. This meant that the caller would have to check for <code>nil</code>. I refactored it to be a function that always returns a non-optional and <code>throws</code> an error if it can&rsquo;t do so (see above related to preferring non-optionals).</p>

<h2>Never <code>guard</code> against multiple conditions</h2>

<p>Consider the following code:</p>

<pre><code class="swift">guard let data = data,
          json = self.jsonFromData(data),
          authors = json["authors"] else {
  throw AuthorParserError
}
</code></pre>

<p>The above avoids the repetition of throwing the <code>AuthorParserError</code> in three places, but in my opinion it would be much better written as follows:</p>

<pre><code class="swift">guard let data = data else {
  throw AuthorParserError
}
guard let json = self.jsonFromData(data) else {
  throw AuthorParserError
}
guard let authors = json["authors"] else {
  throw AuthorParserError
}
</code></pre>

<p>The above is better because you can now test each case individually. And you can be sure that you&rsquo;ve covered each case, because Xcode 7&rsquo;s awesome code coverage facility will highlight any of the conditions that are not tested.</p>

<h2>Always inject dependencies, even if only for testing purposes</h2>

<p>The great thing about Swift&rsquo;s optional function arguments is that you can dictate how something should ordinarily be used but at the same time open up your classes for easy testing - in particular mocking of dependencies.</p>

<p>If your class relies on something to handle network requests, for example, then why not pass that into the <code>init</code> function?</p>

<p>This will make testing a doddle, because you can mock the dependency, ensuring that you are only testing the functionality of that individual class. (Of course you <em>can</em> write more integrated tests too.)</p>

<p>For example:</p>

<pre><code class="swift">public init(requestDelegate: MyClassRequestDelegate = RequestManager()) {
  self.requestDelegate = requestDelegate
}
</code></pre>

<p>The dependency in the above example is actually a protocol, which makes testing very simple, because we just need to mock an object that conforms to the protocol.</p>

<p>(Some people might even demand that the dependency is always injected, instead of defining the defaul. But I feel the main purpose for this type of dependency injection is for easy testing. Unless you&rsquo;re building a library, your app will probably always use the same dependency, so it usually makes sense to have a default.)</p>

<h2>Always <code>typealias</code> completion handlers (where possible)</h2>

<p>Despite <a href="http://www.fuckingclosuresyntax.com">the syntax of closures being somewhat confusing</a>, the syntax for type aliasing a closure is unquestionably simpler than the equivalent <code>typedef</code> in Objective-C. So always define a <code>typealias</code> for your completion handlers (unless they contain generics, in which case you can&rsquo;t).</p>

<pre><code>typealias SomethingCompletion = (result: SomeType) -&gt; Void
</code></pre>

<h2>Use <code>enum</code> to avoid ambiguity</h2>

<p>Here I&rsquo;m referring to a tuple or a set of completion handler arguments that may give rise to ambiguity.</p>

<p>Consider the following completion handler:</p>

<pre><code>doSomething() { (output: NSData?, error: NSError?) in
  // need to check if we have output or error
}
</code></pre>

<blockquote><p>Note that I&rsquo;m still using NSError as part of the completion handler, rather than throwing an exception, because you can&rsquo;t throw an exception asynchronously.</p></blockquote>

<p>The above shows a completion handler which takes two optional values as its arguments. This goes against one of my previous points of &ldquo;avoiding optionals&rdquo; where possible.</p>

<p>What happens in the above if we have neither <code>output</code> nor <code>error</code>. Or what if we have both? Which do we handle?</p>

<p>You should be clear about the arguments to your completion handler, and you can use <code>enum</code> to help. For example, you could define the following:</p>

<pre><code>enum Result&lt;U&gt; {
  case .Success(output: U)
  case .Failure(error: NSError)
}
</code></pre>

<p>Now we can rewrite the above use of the completion handler as:</p>

<pre><code>doSomething() { result in
  switch (result) {
  case .Success(let output):
    // use output
  case .Failure(let error):
    // handle error
  }
}
</code></pre>

<p>This is absolutely clear now that if it was successful, there will be a non-nil output. And we even know the type of it, assuming the <code>doSomething</code> function specialises the generic <code>Result</code>. And likewise it is clear that if it failed there will be a non-nil error. And it can only succeed or fail, so there is no ambiguity.</p>

<h2>A trick for generic completion handling</h2>

<p>Let&rsquo;s say you have a function declared in a protocol as follows:</p>

<pre><code class="swift">protocol ServiceProvider {
  func provideService&lt;U where U: AnyService&gt;(completion: (output: U) -&gt; Void)
}
</code></pre>

<p>When making a class conform to the <code>ServiceProvider</code> protocol (i.e. when implementing this function), as long as we know how to instantiate an object of type <code>U where U: AnyService</code>, then we can return an object of the correct type. (The <code>AnyService</code> protocol must provide a way of returning an instance.)</p>

<p>It is then up to the caller to dictate in the completion closure what type of object should be returned.</p>

<p>For example:</p>

<pre><code>myOtherClass.provideService { (output: RoomService) in
  // do something with the RoomService
}
</code></pre>

<p>The implementation of the <code>provideService</code> function doesn&rsquo;t need to know anything about the <code>RoomService</code> class. It simply has to conform to <code>AnyService</code>, which allows it to be instantiated somehow.</p>

<p>What I really like about this, is that the caller can get back whatever they want back. The caller simply says, &ldquo;in the completion handler, I want an instance of <code>RoomService</code>&rdquo; and the implementation of the function knows how to deliver.</p>

<p>This is in stark contrast with Objective-C, where we would define a completion block argument of type <code>id</code> and the caller would tell the compiler what type of object they <em>expect</em> back when they implement the completion handler. But in Swift, we are <em>guaranteed</em> an object of this type. What&rsquo;s more, we are given this guarantee at compile time.</p>

<h2>Closure best practices</h2>

<p>I try to keep closures as concise as possible.</p>

<ul>
<li>If a closure returns <code>Void</code>, I don&rsquo;t write the return type</li>
<li>If the type of the object can be inferred by the compiler, then don&rsquo;t write the type</li>
<li>If the closure only has a single argument, then don&rsquo;t put it in parentheses</li>
<li>Always make the closure the last argument to a function</li>
<li>Always trail the closure when implementing</li>
<li>Don&rsquo;t write redundant parentheses that the compiler doesn&rsquo;t require (for example, if the function only has one argument and that argument is the closure)</li>
</ul>


<p>These are largely up for debate, but this is the way I&rsquo;m writing things right now. For example:</p>

<pre><code>myObject.doSomething { output in
  // do something with the output
}
</code></pre>

<p>As opposed to:</p>

<pre><code>myObject.doSomething() { (output: NSData?) -&gt; Void in
  // do something with the output
}
</code></pre>

<h2>I hope you enjoyed reading</h2>

<p>If you enjoyed this article, please <a href="http://twitter.com/dodsios">follow me on twitter</a> or subscribe to my <a href="http://octopress.dev/atom.xml">RSS feed</a> for more of the same. I’m happy to discuss this or any other subject in more depth, so feel free to contact me!</p>

<p>And if you&rsquo;d like to join me at <a href="http://www.theappbusiness.com">The App Business</a> to work on some awesome projects for the biggest clients in each industry, then please get in touch &ndash; we&rsquo;re looking for great Swift and Objective-C developers.</p>
]]></content>
  </entry>
  
</feed>
